\begin{appendices}
%\chapter{Figures} \label{chap:figs}
% add info about plots


%\begin{figure}[ht]
%    \centering
%    \includegraphics[width=\linewidth]{images/resources_seq_100.png}
%    \caption{Resource usage of sequential provisioning test with 1 through 100 devices}
%    \label{fig:resources_seq_100}
%\end{figure}

%\begin{figure}[ht]
%    \centering
%    \includegraphics[width=\linewidth]{images/resources_par_100.png}
%    \caption{Resource usage of parallel provisioning test with 1 through 100 devices}
%    \label{fig:resources_par_100}
%\end{figure}

%\begin{figure}[ht]
%    \centering
%    \includegraphics[width=\linewidth]{images/resources_mqtt_com.png}
%    \caption{Resource usage of communication stability test}
%    \label{fig:resources_mqtt_com}
%\end{figure}

%\chapter{Plots}
%Plots \ref{fig:test_1} and \ref{fig:test_2} use the formulas from Chapter \ref{chap:hardware-emulation}, but multiply by the randomized delay (time delta) of every transmission. The resulting jittery output was used to test rules, because the spikes triggered them more often.

%\begin{figure}[ht]
%    \centering
%    \includegraphics[width=1\linewidth]{images/test_1.png}
%    \caption{Dashboard of test with a wide-margin time delta and no time of day adjustments (100 iterations, 5 devices)}
%    \label{fig:test_1}
%\end{figure}

%\begin{figure}[ht]
%    \centering
%    \includegraphics[width=1\linewidth]{images/test_2.png}
%    \caption{Dashboard of test with a normally distributed time delta and no time of day adjustments (100 iterations, 5 devices)}
%    \label{fig:test_2}
%\end{figure}

\chapter{Code}
\begin{figure}[ht]
    \centering
    \begin{lstlisting}[language=json,firstnumber=1]
        {
  "rules": [
    {
      "recurrence": {
        "mins": 0
      },
      "when": {
        "operator": "OR",
        "groups": [
          {
            "operator": "AND",
            "items": [
              {
                "assets": {
                  "types": [
                    "ThingAsset"
                  ],
                  "attributes": {
                    "items": [
                      {
                        "name": {
                          "predicateType": "string",
                          "match": "EXACT",
                          "value": "consumption"
                        },
    \end{lstlisting}
\end{figure}

\begin{figure}[ht]\ContinuedFloat
    \centering
    \begin{lstlisting}[language=json,firstnumber=1]

                        "value": {
                          "predicateType": "number",
                          "operator": "GREATER_THAN",
                          "value": 0.004753314692
                        }
                      },
                      {
                        "name": {
                          "predicateType": "string",
                          "match": "EXACT",
                          "value": "tv"
                        },
                        "value": {
                          "predicateType": "boolean",
                          "value": true
                        }
                      }
                    ]
                  },
                  "ids": [
                    "kXvH9OHQra7HkRjRtmIDdt"
                  ]
                }
              }
            ]
          },
          {
            "operator": "AND",
            "items": [
              {
                "assets": {
                  "types": [
                    "ThingAsset"
                  ],
\end{lstlisting}
\end{figure}

\begin{figure}[ht]\ContinuedFloat
    \centering
    \begin{lstlisting}[language=json,firstnumber=1]
                  "attributes": {
                    "items": [
                      {
                        "name": {
                          "predicateType": "string",
                          "match": "EXACT",
                          "value": "consumption"
                        },
                        "value": {
                          "predicateType": "number",
                          "operator": "GREATER_THAN",
                          "value": 0.004753314692
                        }
                      },
                      {
                        "name": {
                          "predicateType": "string",
                          "match": "EXACT",
                          "value": "tv"
                        },
                        "value": {
                          "predicateType": "value-empty"
                        }
                      }
                    ]
                  },
                  "ids": [
                    "kXvH9OHQra7HkRjRtmIDdt"
                  ]
                }
              }
            ]
          }
        ]
      },
      "then": [
        {
          "action": "write-attribute",
          "target": {
            "assets": {
              "ids": [
                "kXvH9OHQra7HkRjRtmIDdt"
              ],
              "types": [
                "ThingAsset"
              ]
            }
          },
          "value": false,
          "attributeName": "tv"
        }
      ],
      "name": "High consumption SH0"
    }
  ]
}
    \end{lstlisting}
    \caption{An example of a when-then ruleset}
    \label{fig:ruleset}
\end{figure}

\begin{figure}[ht]
    \centering
    \begin{subfigure}{\textwidth}
        \begin{lstlisting}[language=ino, firstnumber=1]
#include <WiFi.h>
#include <PicoMQTT.h>  // MQTT broker/client library
#include <ArduinoJson.h> // JSON library

// WLAN vars
const char *ssid = "vladislav_graduation";
const char *password = "07911392";
WiFiClient wifiClient;

// MQTT vars
const char *server = "192.168.0.202";
PicoMQTT::Server mqtt_broker;
unsigned long pub_timer = 0;
char *sp_topic_sub = "tele/esp32/smart_plug/SENSOR"; // topic for communication with smart plug
char *sp_topic_pub = "home_broker/smart_plug"; // topic for sending sp data to client(s)
char *curr_msg = " "; // global message buffer


void setup() {
  wifi_setup();
  // subscribe and set callback
  mqtt_broker.subscribe(sp_topic_sub, [](char *payload) {
    strcpy(curr_msg, payload); // put payload into global message buffer to avoid processing data in the callback
    //Serial.printf("Message on topic \"tele/esp32/smart_plug/SENSOR\": %s\n", payload);
  });
  mqtt_broker.begin();
}
    \end{lstlisting}
        \caption{Global variables and setup code}
    \end{subfigure}
    \caption{MQTT broker configuration for the ESP32}
\end{figure}

\begin{figure}[ht]\ContinuedFloat
    \centering
    \begin{subfigure}{\textwidth}
        \begin{lstlisting}[language=ino, firstnumber=1]
void loop() {
  mqtt_broker.loop();
  // Serial.printf("%d\n", strcmp(curr_msg, prev_msg));

  // if a new message has been received, enter the if
  if (strcmp(curr_msg, "") != 0) {
      // Serial.printf("Publishing number: %s\n", curr_msg);
      // extract important values from JSON, discard unused values
      JsonDocument sp_data_receive;
      deserializeJson(sp_data_receive, curr_msg);
      float power = sp_data_receive["ENERGY"]["Power"];
      float current = sp_data_receive["ENERGY"]["Current"];
      float voltage = sp_data_receive["ENERGY"]["Voltage"];

      // JSON formatting
      JsonDocument sp_data_send;
      sp_data_send["Power"] = power;
      sp_data_send["Current"] = current;
      sp_data_send["Voltage"] = voltage;

      // publish using JSON publish API 
      auto publish = mqtt_broker.begin_publish(sp_topic_pub, measureJson(sp_data_send));
      serializeJson(sp_data_send, publish);
      publish.send();

      strcpy(curr_msg, ""); // make sure to wipe buffer after publishing
  }
}
    \end{lstlisting}
        \caption{Loop code}
    \end{subfigure}
    \begin{subfigure}{\textwidth}
        \begin{lstlisting}[language=ino, firstnumber=1]
void wifi_setup() {
  Serial.begin(115200);

  Serial.println();
  Serial.println("******************************************************");
  Serial.print("Connecting to ");
  Serial.println(ssid);

  WiFi.begin(ssid, password);

  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }

  Serial.println("");
  Serial.println("WiFi connected");
  Serial.println("IP address: ");  // should be static
  Serial.println(WiFi.localIP());
}

        \end{lstlisting}
        \caption{Wireless client setup}
    \end{subfigure}
    
    \caption{MQTT broker configuration for the ESP32 (cont.)}
    \label{fig:mqtt_broker_full}
\end{figure}


\chapter{Readme}\label{chap:readme}
This appendix is directly taken from the readme file associated with the code. It discusses general information about the code and specific implementation details.

\section{General information}
The purpose of the assignment is to develop scalable IoT systems using OpenRemote and to do so with clear visualization.

\begin{itemize}
    \item Researcher: Vladislav Serafimov, \lstinline{509761@student.saxion.nl}, Applied Computer Science/Electrical and Electronics Engineering
    \item Type of research: Graduation assignment
    \item Duration: 5 months
    \item Related project: NOWATT
\end{itemize}


\section{File guide}
The most important folder is the \lstinline{Source Code} folder. This section describes the purpose of every file and folder in it.

\subsection{Core files}
Three core files make up the project: \lstinline{main.py}, \lstinline{api_interface.py} and \lstinline{sensor_hub.py}.

\subsubsection{\lstinline{main.py}} 
Running this file starts the main test, which simulates a number of devices that communicate with an OpenRemote instance. Passing command-line arguments changes the behavior of the program.
\begin{itemize}
\item  \lstinline{-d} or \lstinline{--devices}: number of simulated devices
\item  \lstinline{-i} or \lstinline{--iterations}: number of messages to send to OpenRemote before exiting the program
\item \lstinline{-e} or \lstinline{--erase}: boolean flag indicating that test data should be erased from OpenRemote; omit to keep data
\item \lstinline{--esp32}: runs the ESP32 test in parallel with the simulated device test
\end{itemize}

\subsubsection{\lstinline{api_interface.py}}
The implementation of the \lstinline{ApiInterface} class can be found in this file. This class creates objects, which can interact with the OpenRemote instance. The following methods have been implemented.
\begin{itemize}

\item \lstinline{__init__(__init__(self, base_address, realm, uname,secret, agent_id=""))}: initialize object and optionally pass an existing OpenRemote agent to be used as parent of new assets; \textbf{details need to be changed whenever a new OpenRemote instance is set up}
\item \lstinline{__get_auth_token(self)}: authenticate user
\item \lstinline{__agent_delete(self)}: deletes parent agent, only needs to be used by the \lstinline{delete_all()} method
\item Assets
    \begin{itemize}
    \item \lstinline{asset_create(self, attributes, asset_type, name)}: creates an OpenRemote asset with a set of attributes; \lstinline{asset_type} should be either \lstinline{sh} or \lstinline{esp32}, the other types should only be used for debugging
    \item \lstinline{asset_get(self, asset_id)}: retrieves an OpenRemote asset
    \item \lstinline{asset_delete(self, asset_ids)}: deletes an OpenRemote asset 
    \item \lstinline{delete_all(self)}: deletes all assets associated with the object, including the agent
    \end{itemize}
\item Dashboards
    \begin{itemize}
    \item \lstinline{dashboard_create(self, asset_ids, dash_type, name)}: creates an OpenRemote dashboard; new layouts can be added by creating a new \lstinline{dash_type} currently only \lstinline{sh} is implemented
    \item \lstinline{dashboard_get(self, dash_id)}: retrieves an OpenRemote dashboard
    \item \lstinline{dashboard_delete(self, dash_id)}: deletes an OpenRemote dashboard
    \end{itemize}
\item Rules: all rules are global
    \begin{itemize}
    \item \lstinline{rule_create_global(self, rule_name, asset_id, rule_type)}: creates an OpenRemote rule; new types of rules can be added by creating a new \lstinline{rule_type}, currently only \lstinline{high_consumption} and \lstinline{low_consumption} are implemented
    \item \lstinline{rule_get_global(self, rule_id)}: retrieves an OpenRemote rule
    \item \lstinline{rule_delete_global(self, rule_id)}: deletes an OpenRemote rule
    \end{itemize}
\item \lstinline{@staticmethod} methods
    \begin{itemize}
    \item \lstinline{__id_gen(length, charset)}: generates a random ID based on the provided \lstinline{length} and \lstinline{charset}
    \item \lstinline{__widget_builder(asset_ids, curr_time, prev_time, attr_type)}: generates dashboard widget JSON object based on a time interval, assets that have the attribute to be plotted and the attribute type
    \item \lstinline{__attr_link_builder(asset_id, attributes)}: creates attribute link, which tells OpenRemote how the JSON object sent to `metrics` should be parsed
    \item \lstinline{__sh_asset_builder(asset_id, attributes, curr_time)}: simplifies the creation of \lstinline{SensorHub}-style assets (also used by the ESP32 asset generator)
    \item \lstinline{__rule_builder(rule_name, asset_id, rule_type)}: simplifies OpenRemote rule creation
    \end{itemize}
\item Other methods
    \begin{itemize}
    \item \lstinline{user_get(self)}: retrieves the current OpenRemote user
    \item \lstinline{model_value_descriptors_get(self, parent_id)}: Gets the value descriptors for the asset model
    \end{itemize}
    \end{itemize}
\subsubsection{\lstinline{sensor_hub.py}}
All functions return simulated data for for the IoT device simulation. The only exceptions are \lstinline{get_all(self)} which returns all attributes and their data type, \lstinline{client_id(self)} which returns the client ID and \lstinline{asset_id(self)} which returns the asset ID. Consult the technical report for the methods used to simulate device data. 

\subsection{Device setup test}
Running \lstinline{multi_test.py} will execute the device setup test, which tests the device provisioning part of \lstinline{main.py}. That part of \lstinline{main.py} is in \lstinline{main_multi_test.py}. The test will be ran for every number of devices between 1 and \lstinline{devices}.  The \lstinline{iterative} flag indicates whether to use iterative (default) or parallel device provisioning. In order to set it to parallel, the \lstinline{iterative} flag in \lstinline{main_multi_test.py} also needs to set to \lstinline{False}. 
\textit{Note: If \lstinline{run_test} is set to \lstinline{False}, the graphs will be displayed only based on previous logs.}

\subsection{MQTT communication test files}
Running \lstinline{mqtt_com_test.py} will execute the device setup test, which tests the MQTT communication of \lstinline{main.py}. \lstinline{main_mqtt_com_test.py} contains an almost identical version, which is used for the test. \lstinline{devices} is an array that can be changed, but the test requires a lot of time, so running it with the default value of \lstinline{[25, 35, 50, 100]} is recommended.
\textit{Note: If \lstinline{run_test} is set to \lstinline{False}, the graphs will be displayed only based on previous logs.}


\subsection{\lstinline{csv_logger.py}}
Both \lstinline{multi_test.py} and \lstinline{mqtt_com_test.py} rely on the \lstinline{CSVLogger} class to write and read test data. The CSV file name is made up of the template and the device number.

\subsection{The \lstinline{plots} folder}
This folder contains the files \lstinline{mqtt_com_test_plot.py} and \lstinline{multi_test_plot.py}, which plot the device setup and MQTT communication test data. The folder also contains \lstinline{mqtt_com_test_plot_detailed.py}, which plots what a single iteration of the test looks like.

All tests track the CPU and memory load during their own runtime. The results can be plotted by running \lstinline{resource_test_plot.py} and selecting one of the log files. The log file name template is \lstinline|f"{test_name}_stat_csv_log_{ending}"| where \lstinline{test_name in ["main", "multi_test", "mqtt_com_test"] is True} and \lstinline{ending = time.strftime("%Y-%m-%d_%H-%M-%S", time.localtime())}.

\subsection{The \lstinline{esp32} folder}
The \lstinline{esp32} folder only contains the \lstinline{mqtt_broker.ino} file. The file contains the following global variables:

\begin{figure}
    \centering
    \begin{lstlisting}[language=ino,firstnumber=1]
// WLAN vars
const char *ssid = "vladislav_graduation";
const char *password = "07911392";
WiFiClient wifiClient;

// MQTT vars
const char *server = "192.168.0.202";
PicoMQTT::Server mqtt_broker;
unsigned long pub_timer = 0;
char *sp_topic_sub = "tele/esp32/smart_plug/SENSOR"; // topic for communication with smart plug
char *sp_topic_pub = "home_broker/smart_plug"; // topic for sending sp data to client(s)
char *curr_msg = " "; // global message buffer
    \end{lstlisting}
    \caption{Global variables of the ESP32 code}
    \label{fig:global_vars}
\end{figure}


Depending on the network configuration some or all variables might need to be changed. See the technical report for more information

\end{appendices}